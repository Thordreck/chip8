#include "Interpreter.hpp"
#include "details/memory.hpp"    // for dumpRomToMemory, initSystemMemory

#include <iostream>

namespace chip8
{
    Interpreter::Interpreter() :
        display_renderer_       ( pixels_ ),
        sound_timer_            ( [this] () { speaker_.Play(); }, [this] () { speaker_.Stop(); } ),
        cpu_cycle_guard_        ( [this] () { InstructionCycle(); }, timers::default_cpu_frequency ),
        timers_tick_guard_      ( [this] () { TickTimers(); }, timers::default_timers_frequency),
        cpu_task_               ( [this] () { CpuCycle(); }, 1us )
    {
        InitializeRam();
    }

    void Interpreter::LoadRom(std::string_view _rom)
    {
        try
        {
            details::dumpRomToMemory(_rom, program_memory_begin_, ram_.end());
            display_renderer_.Begin();
        }
        catch(const std::runtime_error& ex)
        {
            throw Chip8Exception("Error loading rom file ", _rom.data(), ": ", ex.what());
        }
    }

    void Interpreter::StartRom(bool _async)
    {
        program_counter_ = program_memory_begin_;
        cpu_task_.Start(_async);
    }

    void Interpreter::Continue()
    {
        cpu_task_.Start();
    }

    void Interpreter::Pause()
    {
        cpu_task_.Stop();
    }

    void Interpreter::Step()
    {
        CpuCycle();
    }

    bool Interpreter::IsRunning() const
    {
        return cpu_task_.IsRunning();
    }

    void Interpreter::SetCpuFrequency(timers::Frequency _new_frequency)
    {
        cpu_cycle_guard_.SetFrequency(_new_frequency);
    }

    void Interpreter::SetTimersFrequency(timers::Frequency _new_frequency)
    {
        timers_tick_guard_.SetFrequency(_new_frequency);
    }

    void Interpreter::CpuCycle()
    {
        cpu_cycle_guard_.Execute();
        timers_tick_guard_.Execute();
    }

    void Interpreter::InstructionCycle()
    {
        opcodes::OpBytes op_bytes(*program_counter_, *(std::next(program_counter_)));
        const auto bytes_per_opcode = 2;
        std::advance(program_counter_, bytes_per_opcode);
        ProcessInstruction(op_bytes);

        instruction_cycle_completed_();

        //TODO: make this optional
        //cout_logger_.Log(op_bytes);
    }

    void Interpreter::InitializeRam()
    {
        details::initSystemMemory(ram_.begin(), interpreter_memory_end_);
    }

    void Interpreter::TickTimers()
    {
        delay_timer_.Tick();
        sound_timer_.Tick();
        tick_timers_completed_();
    }

    void Interpreter::ProcessInstruction(const opcodes::OpBytes& _op_bytes)
    {
        using namespace opcodes;

        //TODO: check if the instructions generated by the compiler are the same with if/else and a switch
        if ((_op_bytes.first & 0xF0) == 0x00 && (_op_bytes.second & 0xF0) != 0xE0)  
        {
            ExecuteInstruction<OpCodes::OpCode_0NNN>(_op_bytes); 
        }
        else if (_op_bytes.first == 0x00 && _op_bytes.second == 0xE0) 
        {
            ExecuteInstruction<OpCodes::OpCode_00E0>(_op_bytes); 
        }
        else if (_op_bytes.first == 0x00 && _op_bytes.second == 0xEE) 
        {
            ExecuteInstruction<OpCodes::OpCode_00EE>(_op_bytes); 
        }
        else if ((_op_bytes.first & 0xF0) == 0x10) 
        {
            ExecuteInstruction<OpCodes::OpCode_1NNN>(_op_bytes); 
        }
        else if ((_op_bytes.first & 0xF0) == 0x20) 
        {
            ExecuteInstruction<OpCodes::OpCode_2NNN>(_op_bytes); 
        }
        else if ((_op_bytes.first & 0xF0) == 0x30) 
        {
            ExecuteInstruction<OpCodes::OpCode_3XNN>(_op_bytes); 
        }
        else if ((_op_bytes.first & 0xF0) == 0x40) 
        {
            ExecuteInstruction<OpCodes::OpCode_4XNN>(_op_bytes); 
        }
        else if ((_op_bytes.first & 0xF0) == 0x50 && (_op_bytes.second & 0x0F) == 0x0) 
        {
            ExecuteInstruction<OpCodes::OpCode_5XY0>(_op_bytes); 
        }
        else if ((_op_bytes.first & 0xF0) == 0x60) 
        {
            ExecuteInstruction<OpCodes::OpCode_6XNN>(_op_bytes); 
        }
        else if ((_op_bytes.first & 0xF0) == 0x70) 
        {
            ExecuteInstruction<OpCodes::OpCode_7XNN>(_op_bytes); 
        }
        else if ((_op_bytes.first & 0xF0) == 0x80 && (_op_bytes.second & 0x0F) == 0x0) 
        {
            ExecuteInstruction<OpCodes::OpCode_8XY0>(_op_bytes); 
        }
        else if ((_op_bytes.first & 0xF0) == 0x80 && (_op_bytes.second & 0x0F) == 0x1) 
        {
            ExecuteInstruction<OpCodes::OpCode_8XY1>(_op_bytes); 
        }
        else if ((_op_bytes.first & 0xF0) == 0x80 && (_op_bytes.second & 0x0F) == 0x2) 
        {
            ExecuteInstruction<OpCodes::OpCode_8XY2>(_op_bytes); 
        }
        else if ((_op_bytes.first & 0xF0) == 0x80 && (_op_bytes.second & 0x0F) == 0x3) 
        {
            ExecuteInstruction<OpCodes::OpCode_8XY3>(_op_bytes); 
        }
        else if ((_op_bytes.first & 0xF0) == 0x80 && (_op_bytes.second & 0x0F) == 0x4) 
        {
            ExecuteInstruction<OpCodes::OpCode_8XY4>(_op_bytes); 
        }
        else if ((_op_bytes.first & 0xF0) == 0x80 && (_op_bytes.second & 0x0F) == 0x5) 
        {
            ExecuteInstruction<OpCodes::OpCode_8XY5>(_op_bytes); 
        }
        else if ((_op_bytes.first & 0xF0) == 0x80 && (_op_bytes.second & 0x0F) == 0x6) 
        {
            ExecuteInstruction<OpCodes::OpCode_8XY6>(_op_bytes); 
        }
        else if ((_op_bytes.first & 0xF0) == 0x80 && (_op_bytes.second & 0x0F) == 0x7) 
        {
            ExecuteInstruction<OpCodes::OpCode_8XY7>(_op_bytes); 
        }
        else if ((_op_bytes.first & 0xF0) == 0x80 && (_op_bytes.second & 0x0F) == 0xE) 
        {
            ExecuteInstruction<OpCodes::OpCode_8XYE>(_op_bytes); 
        }
        else if ((_op_bytes.first & 0xF0) == 0x90 && (_op_bytes.second & 0x0F) == 0x0) 
        {
            ExecuteInstruction<OpCodes::OpCode_9XY0>(_op_bytes); 
        }
        else if ((_op_bytes.first & 0xF0) == 0xA0) 
        {
            ExecuteInstruction<OpCodes::OpCode_ANNN>(_op_bytes); 
        }
        else if ((_op_bytes.first & 0xF0) == 0xB0) 
        {
            ExecuteInstruction<OpCodes::OpCode_BNNN>(_op_bytes); 
        }
        else if ((_op_bytes.first & 0xF0) == 0xC0) 
        {
            ExecuteInstruction<OpCodes::OpCode_CXNN>(_op_bytes); 
        }
        else if ((_op_bytes.first & 0xF0) == 0xD0) 
        {
            ExecuteInstruction<OpCodes::OpCode_DXYN>(_op_bytes); 
        }
        else if ((_op_bytes.first & 0xF0) == 0xE0 && _op_bytes.second == 0x9E) 
        {
            ExecuteInstruction<OpCodes::OpCode_EX9E>(_op_bytes); 
        }
        else if ((_op_bytes.first & 0xF0) == 0xE0 && _op_bytes.second == 0xA1) 
        {
            ExecuteInstruction<OpCodes::OpCode_EXA1>(_op_bytes); 
        }
        else if ((_op_bytes.first & 0xF0) == 0xF0 && _op_bytes.second == 0x07) 
        {
            ExecuteInstruction<OpCodes::OpCode_FX07>(_op_bytes); 
        }
        else if ((_op_bytes.first & 0xF0) == 0xF0 && _op_bytes.second == 0x0A) 
        {
            ExecuteInstruction<OpCodes::OpCode_FX0A>(_op_bytes); 
        }
        else if ((_op_bytes.first & 0xF0) == 0xF0 && _op_bytes.second == 0x15) 
        {
            ExecuteInstruction<OpCodes::OpCode_FX15>(_op_bytes); 
        }
        else if ((_op_bytes.first & 0xF0) == 0xF0 && _op_bytes.second == 0x18) 
        {
            ExecuteInstruction<OpCodes::OpCode_FX18>(_op_bytes); 
        }
        else if ((_op_bytes.first & 0xF0) == 0xF0 && _op_bytes.second == 0x1E) 
        {
            ExecuteInstruction<OpCodes::OpCode_FX1E>(_op_bytes); 
        }
        else if ((_op_bytes.first & 0xF0) == 0xF0 && _op_bytes.second == 0x29) 
        {
            ExecuteInstruction<OpCodes::OpCode_FX29>(_op_bytes); 
        }
        else if ((_op_bytes.first & 0xF0) == 0xF0 && _op_bytes.second == 0x33) 
        {
            ExecuteInstruction<OpCodes::OpCode_FX33>(_op_bytes); 
        }
        else if ((_op_bytes.first & 0xF0) == 0xF0 && _op_bytes.second == 0x55) 
        {
            ExecuteInstruction<OpCodes::OpCode_FX55>(_op_bytes); 
        }
        else if ((_op_bytes.first & 0xF0) == 0xF0 && _op_bytes.second == 0x65) 
        {
            ExecuteInstruction<OpCodes::OpCode_FX65>(_op_bytes); 
        }
        else
        {
            throw OpCodeException(_op_bytes, "Instruction not recognized");
        }
    }
}
